function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

import Promise from 'bluebird';
// import UpdatesManager from '../updates'

import propEq from 'ramda/src/propEq';
import has from 'ramda/src/has';

import Logger from '../../util/log';
var debug = Logger`api-manager`;

import Auth from '../authorizer';


import blueDefer from '../../util/defer';
import { dTime } from '../time-manager';
import { chooseServer } from '../dc-configurator';

import KeyManager from '../rsa-keys-manger';
import { AuthKeyError } from '../../error';

import { bytesFromHex, bytesToHex } from '../../bin';

import { switchErrors } from './error-cases';
import { delayedCall } from '../../util/smart-timeout';

import Request from './request';

var baseDcID = 2;

var Ln = (length, obj) => obj && propEq('length', length, obj);

export class ApiManager {
  constructor(config, tls, netFabric, { on, emit }) {
    var _this = this;

    this.cache = {
      uploader: {},
      downloader: {},
      auth: {},
      servers: {},
      keysParsed: {}
    };
    this.authPromise = blueDefer();
    this.authBegin = false;
    this.currentDc = 2;
    this.online = false;

    this.networkSetter = (dc, options) => (authKey, serverSalt) => {
      var networker = this.networkFabric(dc, authKey, serverSalt, options);
      this.cache.downloader[dc] = networker;
      return networker;
    };

    function* _ref2(dcID, userAuth) {
      var fullUserAuth = Object.assign({ dcID }, userAuth);
      yield _this.storage.set('dc', dcID);
      yield _this.storage.set('user_auth', fullUserAuth);
      _this.emit('auth.dc', { dc: dcID, auth: userAuth });
    }

    this.setUserAuth = (() => {
      var _ref = _asyncToGenerator(_ref2);

      return function (_x, _x2) {
        return _ref.apply(this, arguments);
      };
    })();

    var {
      server,
      api,
      app: {
        storage,
        publicKeys
      },
      schema,
      mtSchema
    } = config;
    this.apiConfig = api;
    this.publicKeys = publicKeys;
    this.storage = storage;
    this.serverConfig = server;
    this.schema = schema;
    this.mtSchema = mtSchema;
    this.chooseServer = chooseServer(this.cache.servers, server);
    this.on = on;
    this.emit = emit;
    this.TL = tls;
    this.keyManager = KeyManager(this.TL.Serialization, publicKeys, this.cache.keysParsed);
    this.auth = Auth(this.TL, this.keyManager);
    this.networkFabric = netFabric(this.chooseServer);

    //$FlowIssue
    this.mtpInvokeApi = this.mtpInvokeApi.bind(this);
    //$FlowIssue
    this.mtpGetNetworker = this.mtpGetNetworker.bind(this);

    // this.updatesManager = UpdatesManager(apiManager, this.TL)
    // apiManager.updates = this.updatesManager
  }

  mtpGetNetworker(dcID, options = {}) {
    var _this2 = this;

    return _asyncToGenerator(function* () {
      // const isUpload = options.fileUpload || options.fileDownload
      // const cache = isUpload
      //   ? this.cache.uploader
      //   : this.cache.downloader

      var cache = _this2.cache.downloader;
      if (!dcID) throw new Error('get Networker without dcID');

      if (has(dcID, cache)) return cache[dcID];

      var akk = `dc${dcID}_auth_key`;
      var ssk = `dc${dcID}_server_salt`;

      var dcUrl = _this2.chooseServer(dcID, false);

      var networkSetter = _this2.networkSetter(dcID, options);

      if (cache[dcID]) return cache[dcID];

      var authKeyHex = yield _this2.storage.get(akk);
      var serverSaltHex = yield _this2.storage.get(ssk);

      if (Ln(512, authKeyHex)) {
        if (!serverSaltHex || serverSaltHex.length !== 16) serverSaltHex = 'AAAAAAAAAAAAAAAA';
        var _authKey = bytesFromHex(authKeyHex);
        var _serverSalt = bytesFromHex(serverSaltHex);

        return networkSetter(_authKey, _serverSalt);
      }

      if (!options.createNetworker) throw new AuthKeyError();

      var auth = void 0;
      try {
        auth = yield _this2.auth(dcID, _this2.cache.auth, dcUrl);
      } catch (error) {
        return netError(error);
      }

      var { authKey, serverSalt } = auth;

      yield _this2.storage.set(akk, bytesToHex(authKey));
      yield _this2.storage.set(ssk, bytesToHex(serverSalt));

      return networkSetter(authKey, serverSalt);
    })();
  }
  doAuth() {
    var _this3 = this;

    return _asyncToGenerator(function* () {
      _this3.authBegin = true;
      try {
        var storedBaseDc = yield _this3.storage.get('dc');
        var baseDc = storedBaseDc || baseDcID;
        var opts = {
          dcID: baseDc,
          createNetworker: true
        };
        var networker = yield _this3.mtpGetNetworker(baseDc, opts);
        var nearestDc = yield networker.wrapApiCall('help.getNearestDc', {}, opts);
        var { nearest_dc, this_dc } = nearestDc;
        if (storedBaseDc == null) {
          yield _this3.storage.set('dc', nearest_dc);
          if (nearest_dc !== this_dc) yield _this3.mtpGetNetworker(nearest_dc, {
            dcID: nearest_dc,
            createNetworker: true
          });
        }
        debug(`nearest Dc`)(nearestDc);
        _this3.authPromise.resolve();
      } catch (err) {
        _this3.authPromise.reject(err);
      }
    })();
  }
  initConnection() {
    var _this4 = this;

    return _asyncToGenerator(function* () {
      if (!isAnyNetworker(_this4)) {
        if (!_this4.authBegin) _this4.doAuth();
        yield _this4.authPromise.promise;
      }
    })();
  }
  mtpInvokeApi(method, params, options = {}) {
    var _this5 = this;

    return _asyncToGenerator(function* () {
      var deferred = blueDefer();
      var rejectPromise = function (error) {
        var err = void 0;
        if (error instanceof Error) err = error;else {
          err = new Error();
          err.data = error;
        }
        // if (!error)
        //   err = { type: 'ERROR_EMPTY', input: '' }
        // else if (!is(Object, error))
        //   err = { message: error }
        // else err = error
        deferred.reject(err);

        if (!options.noErrorBox) {
          //TODO weird code. `error` changed after `.reject`?

          /*err.input = method
           err.stack =
            stack ||
            hasPath(['originalError', 'stack'], error) ||
            error.stack ||
            (new Error()).stack*/
          _this5.emit('error.invoke', error);
        }
      };

      function _ref3(waitTime) {
        return delayedCall(_req.performRequest, +waitTime * 1e3);
      }

      function _ref4() {
        return networker;
      }

      function _ref5(networker) {
        _req.config.networker = networker;
        return _req.performRequest();
      }

      function _ref6(error) {
        var deferResolve = deferred.resolve;
        var apiSavedNet = _ref4;
        var apiRecall = _ref5;
        console.error(dTime(), 'Error', error.code, error.type, baseDcID, _dcID);

        return switchErrors(error, options, _dcID, baseDcID)(error, options, _dcID, _this5.emit, rejectPromise, requestThunk, apiSavedNet, apiRecall, deferResolve, _this5.mtpInvokeApi, _this5.storage);
      }

      try {
        yield _this5.initConnection();

        var requestThunk = _ref3;

        var _dcID = options.dcID ? options.dcID : yield _this5.storage.get('dc');

        var networker = yield _this5.mtpGetNetworker(_dcID, options);

        var cfg = {
          networker,
          dc: _dcID,
          storage: _this5.storage,
          getNetworker: _this5.mtpGetNetworker,
          netOpts: options
        };
        var _req = new Request(cfg, method, params);

        _req.performRequest().then(deferred.resolve, _ref6).catch(rejectPromise);
      } catch (e) {
        deferred.reject(e);
      }
      return deferred.promise;
    })();
  }

}

var isAnyNetworker = ctx => Object.keys(ctx.cache.downloader).length > 0;

var netError = error => {
  console.log('Get networker error', error, error.stack);
  return Promise.reject(error);
};
//# sourceMappingURL=index.js.map