{"version":3,"sources":["../../src/tl/index.js"],"names":["EventEmitter","is","has","uintToInt","intToUint","bytesToHex","gzipUncompress","bytesToArrayBuffer","readLong","readInt","readBytes","readString","readDouble","writeInt","writeIntBytes","writeBytes","writeDouble","writeBool","writeLong","Layout","getFlags","isSimpleType","getTypeProps","TypeBuffer","TypeWriter","getNakedType","getTypeConstruct","Logger","debug","PACKED","apiLayer","mtLayer","Serialization","constructor","mtproto","startMaxLength","api","mtApi","writer","maxLength","reset","getBytes","typed","getBytesTyped","getBytesPlain","storeMethod","methodName","params","layer","pred","funcs","get","Error","id","hasFlags","flags","storeObject","param","paramName","name","typeClass","fieldObj","isFlag","typeDefaults","isVector","Array","isArray","TypeError","length","entries","i","elem","returns","obj","type","field","substr","itemType","toLowerCase","Object","schema","selectSchema","predicate","isBare","constructorData","charAt","constructors","tlConst","condType","fieldBit","indexOf","split","emitter","wildcard","Deserialization","buffer","override","typeBuffer","fetchInt","fetchBool","offset","fetchObject","fetchIntBytes","bits","len","bytes","next","fetchRawBytes","byteView","byteLength","fetchPacked","compressed","uncompressed","newDeserializer","fetchVector","constructorCmp","result","push","fallback","typeProps","index","constructorsIndex","schemaFallback","finded","overrideKey","apply","value","seqSet","emit","getOffset","fetchEnd","isEnd","TL","on","bind"],"mappings":"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","file":"index.js","sourcesContent":["//@flow\n\nimport EventEmitter from 'eventemitter2'\nimport is from 'ramda/src/is'\nimport has from 'ramda/src/has'\n\nimport { uintToInt, intToUint, bytesToHex,\n  gzipUncompress, bytesToArrayBuffer } from '../bin'\n\nimport { readLong, readInt, readBytes, readString, readDouble } from './reader'\nimport { writeInt, writeIntBytes, writeBytes, writeDouble,\n  writeBool, writeLong } from './writer'\n\nimport Layout, { getFlags, isSimpleType, getTypeProps } from '../layout'\nimport { TypeBuffer, TypeWriter, getNakedType, getTypeConstruct } from './type-buffer'\nimport type { TLSchema } from './index.h'\n\n// import writer from '../util/file-log'\n\n// const storeMethodLog = writer('storeMethod')\n// const fetchObjectLog = writer('fetchObject')\n\nimport Logger from '../util/log'\nconst debug = Logger`tl`\n\nconst PACKED = 0x3072cfa1\n\ntype SerialConstruct = {\n  mtproto: boolean,\n  startMaxLength: number\n}\n\nlet apiLayer: Layout\nlet mtLayer: Layout\n\nexport class Serialization {\n  writer: TypeWriter = new TypeWriter()\n  mtproto: boolean\n  api: TLSchema\n  mtApi: TLSchema\n  apiLayer: Layout\n  mtLayer: Layout\n  constructor({ mtproto, startMaxLength }: SerialConstruct, api: TLSchema, mtApi: TLSchema) {\n    this.api = api\n    this.mtApi = mtApi\n\n    this.writer.maxLength = startMaxLength\n\n    this.writer.reset()\n    this.mtproto = mtproto\n  }\n\n  getBytes(typed?: boolean) {\n    if (typed)\n      return this.writer.getBytesTyped()\n    else\n      return this.writer.getBytesPlain()\n  }\n\n  storeMethod(methodName: string, params) {\n    // const logId = storeMethodLog.input({\n    //   methodName,\n    //   params\n    // })\n    const layer = this.mtproto\n      ? mtLayer\n      : apiLayer\n    const pred = layer.funcs.get(methodName)\n    if (!pred) throw new Error(`No method name ${methodName} found`)\n\n    writeInt(this.writer,\n             intToUint(`${pred.id}`),\n             `${methodName}[id]`)\n    if (pred.hasFlags) {\n      const flags = getFlags(pred)(params)\n      this.storeObject(flags, '#', `f ${methodName} #flags ${flags}`)\n    }\n    for (const param of pred.params) {\n      const paramName = param.name\n      const typeClass = param.typeClass\n      let fieldObj\n      if (!has(paramName, params)) {\n        if (param.isFlag) continue\n        else if (layer.typeDefaults.has(typeClass))\n          fieldObj = layer.typeDefaults.get(typeClass)\n        else if (isSimpleType(typeClass)) {\n          switch (typeClass) {\n            case 'int': fieldObj = 0; break\n            // case 'long': fieldObj = 0; break\n            case 'string': fieldObj = ' '; break\n            // case 'double': fieldObj = 0; break\n            case 'true': fieldObj = true; break\n            // case 'bytes': fieldObj = [0]; break\n          }\n        }\n        else throw new Error(`Method ${methodName} did not receive required argument ${paramName}`)\n      } else {\n        fieldObj = params[paramName]\n      }\n      if (param.isVector) {\n        if (!Array.isArray(fieldObj))\n          throw new TypeError(`Vector argument ${paramName} in ${methodName} required Array,`  +\n          //$FlowIssue\n          ` got ${fieldObj} ${typeof fieldObj}`)\n        writeInt(this.writer, 0x1cb5c415, `${paramName}[id]`)\n        writeInt(this.writer, fieldObj.length, `${paramName}[count]`)\n        for (const [ i, elem ] of fieldObj.entries())\n          this.storeObject(elem, param.typeClass, `${paramName}[${i}]`)\n      } else\n        this.storeObject(fieldObj, param.typeClass, `f ${methodName}(${paramName})`)\n    }\n    /*let condType\n    let fieldBit\n    for (const param of methodData.params) {\n      let type = param.type\n      if (type.indexOf('?') !== -1) {\n        condType = type.split('?')\n        fieldBit = condType[0].split('.')\n        if (!(params[fieldBit[0]] & 1 << fieldBit[1])) {\n          continue\n        }\n        type = condType[1]\n      }\n      const paramName = param.name\n      const stored = params[paramName]\n      if (!stored)\n        stored = this.emptyOfType(type, schema)\n      if (!stored)\n        throw new Error(`Method ${methodName}.`+\n          ` No value of field ${ param.name } recieved and no Empty of type ${ param.type }`)\n      this.storeObject(stored, type, `f ${methodName}(${paramName})`)\n    }*/\n\n\n    // storeMethodLog.output(logId, {\n    //   pred,\n    //   writer: this.writer\n    // })\n    return pred.returns\n  }\n  /*emptyOfType(ofType, schema: TLSchema) {\n    const resultConstruct = schema.constructors.find(\n      ({ type, predicate }: TLConstruct) =>\n        type === ofType &&\n        predicate.indexOf('Empty') !== -1)\n    return resultConstruct\n      ? { _: resultConstruct.predicate }\n      : null\n  }*/\n  storeObject(obj: *, type: string, field: string) {\n    switch (type) {\n      case '#':\n      case 'int':\n        return writeInt(this.writer, obj, field)\n      case 'long':\n        return writeLong(this.writer, obj, field)\n      case 'int128':\n        return writeIntBytes(this.writer, obj, 128, field)\n      case 'int256':\n        return writeIntBytes(this.writer, obj, 256, field)\n      case 'int512':\n        return writeIntBytes(this.writer, obj, 512, field)\n      case 'string':\n        return writeBytes(this.writer, obj, `${field}:string`)\n      case 'bytes':\n        return writeBytes(this.writer, obj, field)\n      case 'double':\n        return writeDouble(this.writer, obj, field)\n      case 'Bool':\n        return writeBool(this.writer, obj, field)\n      case 'true':\n        return\n    }\n\n    if (Array.isArray(obj)) {\n      if (type.substr(0, 6) == 'Vector')\n        writeInt(this.writer, 0x1cb5c415, `${field}[id]`)\n      else if (type.substr(0, 6) != 'vector') {\n        throw new Error(`Invalid vector type ${  type}`)\n      }\n      const itemType = type.substr(7, type.length - 8) // for \"Vector<itemType>\"\n      writeInt(this.writer, obj.length, `${field}[count]`)\n      for (let i = 0; i < obj.length; i++) {\n        this.storeObject(obj[i], itemType, `${field  }[${  i  }]`)\n      }\n      return true\n    }\n    else if (type.substr(0, 6).toLowerCase() == 'vector') {\n      throw new Error('Invalid vector object')\n    }\n\n    if (!is(Object, obj))\n      throw new Error(`Invalid object for type ${  type}`)\n\n    const schema = selectSchema(this.mtproto, this.api, this.mtApi)\n\n    const predicate = obj['_']\n    let isBare = false\n    let constructorData = false\n    isBare = type.charAt(0) == '%'\n    if (isBare)\n      type = type.substr(1)\n\n\n    for (const tlConst of schema.constructors) {\n      if (tlConst.predicate == predicate) {\n        constructorData = tlConst\n        break\n      }\n    }\n\n    if (!constructorData)\n      throw new Error(`No predicate ${predicate} found`)\n\n    if (predicate == type)\n      isBare = true\n\n    if (!isBare)\n      writeInt(this.writer,\n               intToUint(constructorData.id),\n               `${field}.${predicate}[id]`)\n\n    let condType\n    let fieldBit\n\n    for (const param of constructorData.params) {\n      type = param.type\n      if (type.indexOf('?') !== -1) {\n        condType = type.split('?')\n        fieldBit = condType[0].split('.')\n        if (!(obj[fieldBit[0]] & 1 << fieldBit[1])) {\n          continue\n        }\n        type = condType[1]\n      }\n\n      this.storeObject(obj[param.name], type, `${field}.${  predicate  }.${  param.name  }`)\n    }\n\n    return constructorData.type\n  }\n\n}\n\nconst emitter = new EventEmitter({ wildcard: true })\n\nexport class Deserialization {\n  typeBuffer: TypeBuffer\n  override: Object\n  mtproto: boolean\n  api: TLSchema\n  mtApi: TLSchema\n  emitter: EventEmitter\n  constructor(buffer: Buffer, { mtproto, override }: DConfig, api: TLSchema, mtApi: TLSchema) {\n    this.api = api\n    this.mtApi = mtApi\n    this.override = override\n\n    this.typeBuffer = new TypeBuffer(buffer)\n    this.mtproto = mtproto\n    this.emitter = emitter\n\n    // const fetchObject = this.fetchObject.bind(this)\n\n    // const mock = (type, field) => {\n    //   const logId = fetchObjectLog.input({\n    //     type,\n    //     typeBuffer: this.typeBuffer,\n    //     field\n    //   })\n    //   const result = fetchObject(type, field)\n    //   fetchObjectLog.output(logId, {\n    //     typeBuffer: this.typeBuffer,\n    //     result\n    //   })\n    //   return result\n    // }\n    // this.fetchObject = mock\n  }\n\n  // log('int')(field, i.toString(16), i)\n  readInt = (field: string) =>\n    readInt(this.typeBuffer, field)\n\n  fetchInt(field: string = '') {\n    return this.readInt(`${ field }:int`)\n  }\n\n  fetchBool(field: string = '') {\n    const i = this.readInt(`${ field }:bool`)\n    switch (i) {\n      case 0x997275b5: return true\n      case 0xbc799737: return false\n      default: {\n        this.typeBuffer.offset -= 4\n        return this.fetchObject('Object', field)\n      }\n    }\n  }\n  fetchIntBytes(bits: number, field: string = '') {\n    if (bits % 32)\n      throw new Error(`Invalid bits: ${bits}`)\n\n    const len = bits / 8\n\n    const bytes = this.typeBuffer.next(len)\n\n    debug(`int bytes`)(bytesToHex(bytes), `${ field }:int${  bits}`)\n\n    return bytes\n  }\n\n  fetchRawBytes(len: number | false, field: string = '') {\n    if (len === false) {\n      len = this.readInt(`${ field }_length`)\n      if (len > this.typeBuffer.byteView.byteLength)\n        throw new Error(`Invalid raw bytes length: ${  len  }, buffer len: ${this.typeBuffer.byteView.byteLength}`)\n    }\n    const bytes = this.typeBuffer.next(len)\n    debug(`raw bytes`)(bytesToHex(bytes), field)\n\n    return bytes\n  }\n\n  fetchPacked(type, field: string = '') {\n    const compressed = readBytes( this.typeBuffer, `${field}[packed_string]`)\n    const uncompressed = gzipUncompress(compressed)\n    const buffer = bytesToArrayBuffer(uncompressed)\n    const newDeserializer = new Deserialization(\n      buffer, {\n        mtproto : this.mtproto,\n        override: this.override\n      },\n      this.api, this.mtApi)\n\n    return newDeserializer.fetchObject(type, field)\n  }\n\n  fetchVector(type: string, field: string = '') {\n    // const typeProps = getTypeProps(type)\n    if (type.charAt(0) === 'V') {\n      const constructor = this.readInt(`${field}[id]`)\n      const constructorCmp = uintToInt(constructor)\n\n      if (constructorCmp === PACKED)\n        return this.fetchPacked(type, field)\n      if (constructorCmp !== 0x1cb5c415)\n        throw new Error(`Invalid vector constructor ${constructor}`)\n    }\n    const len = this.readInt(`${field}[count]`)\n    const result = []\n    if (len > 0) {\n      const itemType = type.substr(7, type.length - 8) // for \"Vector<itemType>\"\n      for (let i = 0; i < len; i++)\n        result.push(this.fetchObject(itemType, `${field}[${i}]`))\n    }\n\n    return result\n  }\n\n  fetchObject(type, field: string = '') {\n\n    switch (type) {\n      case '#':\n      case 'int':\n        return this.fetchInt(field)\n      case 'long':\n        return readLong(this.typeBuffer, field)\n      case 'int128':\n        return this.fetchIntBytes(128, field)\n      case 'int256':\n        return this.fetchIntBytes(256, field)\n      case 'int512':\n        return this.fetchIntBytes(512, field)\n      case 'string':\n        return readString(this.typeBuffer, field)\n      case 'bytes':\n        return readBytes(this.typeBuffer, field)\n      case 'double':\n        return readDouble(this.typeBuffer, field)\n      case 'Bool':\n        return this.fetchBool(field)\n      case 'true':\n        return true\n    }\n    let fallback\n    field = field || type || 'Object'\n\n    // const layer = this.mtproto\n    //   ? mtLayer\n    //   : apiLayer\n    const typeProps = getTypeProps(type)\n    // layer.typesById\n\n    if (typeProps.isVector)\n      return this.fetchVector(type, field)\n\n    const schema = selectSchema(this.mtproto, this.api, this.mtApi)\n    let predicate = false\n    let constructorData = false\n\n    if (typeProps.isBare)\n      constructorData = getNakedType(type, schema)\n    else {\n      const constructor = this.readInt(`${field}[id]`)\n      const constructorCmp = uintToInt(constructor)\n\n      if (constructorCmp === PACKED)\n        return this.fetchPacked(type, field)\n\n      let index = schema.constructorsIndex\n      if (!index) {\n        schema.constructorsIndex = index = {}\n        for (let i = 0; i < schema.constructors.length; i++)\n          index[schema.constructors[i].id] = i\n      }\n      const i = index[constructorCmp]\n      if (i)\n        constructorData = schema.constructors[i]\n\n      fallback = false\n      if (!constructorData && this.mtproto) {\n        const schemaFallback = this.api\n        const finded = getTypeConstruct(constructorCmp, schemaFallback)\n        if (finded) {\n          constructorData = finded\n          delete this.mtproto\n          fallback = true\n        }\n      }\n      if (!constructorData) {\n        throw new Error(`Constructor not found: ${constructor} ${this.fetchInt()} ${this.fetchInt()}`)\n      }\n    }\n\n    predicate = constructorData.predicate\n\n    const result = { '_': predicate }\n    const overrideKey = (this.mtproto ? 'mt_' : '') + predicate\n\n    if (this.override[overrideKey]) {\n      this.override[overrideKey].apply(this, [result, `${field}[${predicate}]`])\n    } else {\n      for (const param of constructorData.params) {\n        type = param.type\n        // if (type === '#' && isNil(result.pFlags))\n        //   result.pFlags = {}\n        if (type.indexOf('?') !== -1) {\n          const condType = type.split('?')\n          const fieldBit = condType[0].split('.')\n          if (!(result[fieldBit[0]] & 1 << fieldBit[1]))\n            continue\n          type = condType[1]\n        }\n        const paramName = param.name\n        const value = this.fetchObject(type, `${field}[${predicate}][${paramName}]`)\n\n        result[paramName] = value\n      }\n    }\n\n    if (fallback)\n      this.mtproto = true\n\n    if (apiLayer.seqSet.has(predicate)) {\n      this.emitter.emit('seq', result)\n    }\n\n    return result\n  }\n\n  getOffset() {\n    return this.typeBuffer.offset\n  }\n\n  fetchEnd() {\n    if (!this.typeBuffer.isEnd())\n      throw new Error('Fetch end with non-empty buffer')\n    return true\n  }\n\n}\n\nconst selectSchema = (mtproto: boolean, api: TLSchema, mtApi: TLSchema) => mtproto\n  ? mtApi\n  : api\n\ntype DConfig = {\n  mtproto: boolean,\n  override: Object\n}\n\nexport type DeserializationFabric = (\n  buffer: Buffer,\n  config?: {\n    mtproto?: boolean,\n    override?: Object\n  }) => Deserialization\n\nexport type SerializationFabric = (\n  config?: {\n    mtproto?: boolean,\n    startMaxLength?: number\n  }) => Serialization\n\nexport type TLFabric = {\n  apiLayer: Layout,\n  mtLayer: Layout,\n  Serialization: SerializationFabric,\n  Deserialization: DeserializationFabric\n}\n\nexport const TL = (api: TLSchema, mtApi: TLSchema) => ({\n  on           : emitter.on.bind(emitter),\n  apiLayer     : !apiLayer ? apiLayer = new Layout(api) : apiLayer,\n  mtLayer      : !mtLayer ? mtLayer = new Layout(mtApi) : mtLayer,\n  Serialization: ({ mtproto = false, startMaxLength = 2048 /* 2Kb */ } = {}) =>\n    new Serialization({ mtproto, startMaxLength }, api, mtApi),\n  Deserialization: (buffer: Buffer, { mtproto = false, override = {} }: DConfig = {}) =>\n    new Deserialization(buffer, { mtproto, override }, api, mtApi)\n})\n\n\nexport { TypeWriter } from './type-buffer'\nexport default TL\n"]}