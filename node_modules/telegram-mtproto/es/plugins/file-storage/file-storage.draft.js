function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

import Promise from 'bluebird';
import toPairs from 'ramda/src/toPairs';
import fromPairs from 'ramda/src/fromPairs';

// import type { AsyncStorage } from '../index.h'

var { watchFile } = require('fs');

import { readData, writeData } from './fixtures';

function _ref(update) {
  return console.log('update', update);
}

export class FileSystemDriver {
  constructor(filepath) {
    this.watcher = ({ mtime }) => {
      var newTime = mtime.getTime();
      var needUpdate = this.syncTime < newTime;
      console.log(`watch curr`, needUpdate, mtime.toTimeString(), this.syncTimeString);
      if (needUpdate) {
        this.read(newTime).then(_ref);
      }
    };

    this.filepath = filepath;
    this.updateTime();
    watchFile(filepath, { interval: 500 }, this.watcher);
  }
  get syncTimeString() {
    var date = new Date(this.syncTime);
    var str = date.toTimeString();
    return str;
  }
  updateTime(syncTime) {
    return this.syncTime = syncTime ? syncTime : Date.now();
  }
  mergeUpdate(update, syncTime) {
    var _this = this;

    return _asyncToGenerator(function* () {
      if (syncTime >= _this.syncTime) {
        _this.updateTime(syncTime);
        yield writeData(_this.filepath, update);
      }
    })();
  }
  write(obj) {
    var _this2 = this;

    return _asyncToGenerator(function* () {
      var time = _this2.updateTime();
      var str = JSON.stringify(obj);
      yield _this2.mergeUpdate(str, time);
    })();
  }
  read(syncTime) {
    var _this3 = this;

    return _asyncToGenerator(function* () {
      _this3.updateTime(syncTime);
      var str = yield readData(_this3.filepath);

      if (str.length === 0) {
        yield _this3.write({});
        _this3.updateTime();
        str = yield readData(_this3.filepath);
      }
      var result = JSON.parse(str);
      return result;
    })();
  }

}

class FileStorageInstance {
  constructor(filepath, store) {
    this.store = new Map();

    this.driver = new FileSystemDriver(filepath);
    this.save(store);
  }
  save() {
    var _this4 = this;

    return _asyncToGenerator(function* () {
      var obj = fromPairs([..._this4.store.entries()]);
      yield _this4.driver.write(obj);
    })();
  }
  load(obj) {
    this.store.clear();
    for (var _iterator = toPairs(obj), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
      var _ref2;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref2 = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref2 = _i.value;
      }

      var [_key, value] = _ref2;

      this.store.set(_key, value);
    }
  }

  get(key) {
    return Promise.resolve(this.store.get(key));
  }
  set(key, val) {
    this.store.set(key, val);
    return Promise.resolve();
  }
  remove(...keys) {
    return Promise.resolve(keys.map(key => this.store.delete(key)));
  }
  clear() {
    this.store.clear();
    return Promise.resolve();
  }
}

/*const initializeFileStorage = async (filepath: string) => {
  let needToCreate = false
  try {
    await checkAccess(filepath)
  } catch (err) {
    switch (err.code) {
      case 'ENOENT': needToCreate = true; break
      case 'EPERM' : throw err
      default: throw err
    }
  }
  if (needToCreate)
    await createFile(filepath)

  const storage = new FileStorageInstance(filepath, {})
  return storage
  // await pause(5e3)

  // const readed = await storage.read()

  // console.log(`readed`, storage.syncTimeString, readed)

  // readed.field = { value: 'field' }
  // readed.data = ['str', 48, { ok: null }]

  // await pause()

  // await storage.write(readed)

  // await pause(5e3)

  // const newReaded = await storage.read()

  // console.log(`newReadedObj`, storage.syncTimeString, newReaded)

}*/

// export const FileStorage = (filepath: string): Promise<AsyncStorage> =>
//   initializeFileStorage(filepath)

export default FileStorageInstance;
//# sourceMappingURL=file-storage.draft.js.map